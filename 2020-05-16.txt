1.Linux内核架构
	a.纵向
		纵向来看, Linux内核分为三层架构, 上层接口层提供统一的系统调用接口; 中间层功能层为内核功能逻辑的实现, 独立于具体的体系架构; 底层驱动层提供依赖于具体体系的板级支持包(BSP)
	b.横向
		横向来看, Linux内核分为5个子系统：进程调度、内存管理、虚拟文件系统、网络接口、进程间通信IPC
			i. 进程调度子系统SCHED：控制进程对CPU的访问, 采用合理的策略使得所有进程能够合理地公用CPU
			ii.内存管理子系统MM：允许多个线程安全地共享内存区域。
			iii.虚拟文件子系统VFS：实现Linux的“一切皆是文件”思想, 隐藏各种硬件细节, 为所有设备提供统一的接口
			iv.网络接口子系统NET：提供对各种网络标准的存取和各种网络硬件的支持
			v.进程间通信子系统IPC：提供进程间通信的支持	

2.什么是系统调用
	https://www.jianshu.com/p/9c62a65b6162
	https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html
	https://www.jianshu.com/p/f4c04cf8e406
	https://zcfy.cc/article/the-definitive-guide-to-linux-system-calls-670.html?t=new
	概念、具体实现方式
		概念：系统调用system call概念上来说是系统提供的应用程序同系统之间的接口。
			对于操作系统老说, 一般有4个特权级别, 编号ring0-ring3, Linux只用了Ring0和Ring3, 分别对应用户态与内核态。
		实现：通过系统调用能够实现程序从用户态到内核态的切换, 具体来说是通过中断实现这一切换过程。
			中断由中断号和中断处理程序组成,  内核中由中断向量表实现中断号和中断处理程序的对应。
			(旧版, Linux2.5之前、软中断机制)内核采用int 0x80触发所有的系统调用, 而不是一个中断对应一个系统调用。对于区分不同的系统调用, 则是通过系统调用号实现, 0x80中断只是完成系统调用号的传递(通过寄存器)。
			Linux中用户态和内核态使用的是不同的栈, 负责各自的函数调用, 互不干扰。执行int $0x80, 程序需要由用户态切换到内核态, 程序当前栈也由用户栈切换到内核栈。当前栈->ESP寄存器指向的栈
			
			(新版, Linux2.5引入)使用快速系统调用指令, 32位系统使用sysenter/sysexit指令, 64位系统使用syscall/sysret指令。
				sysenter/sysexit指令：通过写入指定的MSRs(特殊模块寄存器)来指定内核态的代码段和代码入口以及堆栈段和堆栈指针,  这些寄存器包括IA32_SYSENTER_CS、IA32_SYSENTER_EIP(内核指定的将要执行的程序的地址)、IA32_SYSENTER_ESP。
				syscall/sysret指令:把系统调用号传入rax寄存器, syscall的参数存入其他通用寄存器。
				
3.Linux中断处理程序架构
	设备的中断会打断当前内核经常中的正常调度和运行, 但系统又有更高吞吐量的需求, 故中断服务程序一般要求尽量短。
	在Linux内核中, 为平衡中断时间尽量短与中断处理的大工作量, 在Linux内核中采用了两个半部的架构: 顶半部(Top Half)和底半部(Bottom Half)。其中顶半部用于完成尽量少的紧急功能, 只是简单的读取寄存器中的中断状态, 并在清除中断标志位后进行"登记中断"工作, 即将底半部处理程序加入到设备的底半部执行队列中去。
   中断处理工作的中心在底半部进行, 需要通过底半部来完成中断时间的绝大多数任务。
	在Linux中查看/proc/interrupts文件可以获取系统中中断的统计信息, 并能统计出每个中断在CPU中发生的次数。
	Linux中断编程的一些常用函数: request_irq()/free_irq()/disable_irq()/disable_irq_nosync()/enable_irq()/local_xxx(本CPU内)
	Linux底半部机制：tasklet、工作队列、软中断、线程化irq(threaded_irq).
		tasklet的执行上下文是软中断。工作队列的使用方法与tasklet类似, 但其执行上下文是内核线程。
		
4.软中断、硬中断、信号区别
	硬中断：外部设备/接口对CPU的中断, 是硬件级别的支持
	软中断：中断底半部的一种处理机制softirq
	信号：由内核(或其他进程)对某个进程的中断
	软中断要区别与由软件指令触发的中断(系统调用中)。
	
5.C++中的值类型、右值引用
	https://blog.csdn.net/dbzhang800/article/details/6663353
	a.值类型
		左值与右值的根本区别在于能否获取内存地址; ++x与x++——前者是lvalue, 后者是rvalue, 前者修改自身并返回自身, 后者创建一个临时对象修改x值再返回临时对象
		C++中分为左值(lvalue)与右值(rvalue), 右值又分为纯右值(prvalue)和将亡值(xvalue)
			纯右值(prvalue)：传统意义上的右值, 临时变量和不跟对象关联的字面变量
			将亡值(xvalue)：指通过"右值引用"产生的对象, 可以理解为通过“盗取”其他变量内存空间的方式获取到的值
				通常是将要被移动的对象, 比如返回右值引用T&的函数返回、std::move的返回值、转换为T&&的类型转换函数的返回值
		对于函数调用, 根据返回值类型不同可以为lvalue、xvalue、prvalue
		C++11之中，可以使用标准库中添加的模板类is_lvalue_reference来判断表达式是否为左值，is_rvalue_reference来判断是否为右值。
		组合：
			lvalue + xvalue = glvalue => general lvalue 泛左值
			xvalue + prvalue = rvalue => 右值
	b.右值引用
		定义：对一个右值进行引用的类型 &&a
		意义：为临时变量也就是右值续命。(右值在表达式结束后就消亡了, 要引用就会动用昂贵的拷贝函数)
			右值引用是用来转移语义的, 转移语义可以将资源从一个对象转移到另一个对象, 减少不必要的临时对象的创建、销毁与拷贝
			
6.




C++后端：
	职位技术要求：
		C++常用语法
		Linux操作系统提供的API函数, 熟练掌握条件变量 main手册： socket、accpet、connet、
		多线程编程
		Linux网络通信      
			Nagle算法、滑动窗口、拥塞控制、TCP端口等
			socket、accpet、connet、recv、send
			网络通信模型：阻塞、非阻塞、poll、epoll、select  弄清楚网络通信模型的具体实现
		学习C++语法：关键字auto、初始化列表等
		数据库：
			基础：基本的数据库理论知识、常见的数据库基本操作(增删查改、建表、建库)、数据库权限理论、索引(结构)、数据库锁()
			进阶：分表分库
		C++开发技能：
			如何检测内存泄漏
			写实复制COW
			智能指针实现
			池化思想(线程池、内存池、资源池)
			
			设计日志模块
			
			断线重连、心跳、通信协议设置、服务的水平扩展/垂直扩展
			
		多看开源项目
			先看细节, 学习细节
		
		编码习惯：
			1.注释  循环/类等}后, end of
			2.宏定义
			3.成员变量  按类型共同放置
			4.
			
		实践：
			模块化：日志系统模块、程序性能统计、内存池模块、资源池模块、界面模块
		
	面试篇：
		简历：
			专业技能：
				问题：不要罗列不需要的技能、项目经验->突出技术与解决的问题、
				先写通用技术后写专业领域的技术。通用技术指的是算法数据结构、操作系统、网络编程; 专业的技术领域指C++、JAVA等特定的编程语言、各种框架、开源软件
				例：
					 1. 熟悉常用的算法和数据结构；
					 2. 熟悉多线程编程技术，熟悉常见的线程同步、进程通信技术；
					 3. 熟悉网络编程，熟悉 TCP/IP 通信原理，熟悉 HTTP、FTP 等常用协议；
					 4. 熟悉 C/C++，熟悉 C++11，良好的面向对象思维和编码风格； 
					 5. 熟悉 Linux 系统常用操作，熟练使用 gcc/gdb 等 Linux 下开发工具； 
					 6. 熟悉 mysql、redis 等数据库原理，熟悉常见数据库调优技术； 
					 7. 熟悉 kafka、RabbitMQ 等消息中间件；
					 8. 熟悉金融交易系统，有大宗交易系统开发经验
			项目经验
				不要挖坑
			自我评价
				个人特点
				
				结构：
					1.个人基本信息
					2.求职意向  (Linux C++后端开发)
					3.
