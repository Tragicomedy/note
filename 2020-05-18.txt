1.C++类构造函数初始化列表
	类对象的构造顺序是这样的：
		1.分配内存，调用构造函数时，隐式／显示的初始化各数据成员；
		2.进入构造函数后在构造函数中执行一般赋值与计算。
	必须使用初始化列表的三种情况：
		情况一、需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)； 
		情况二、需要初始化const修饰的类成员或初始化引用成员数据；
		情况三、子类初始化父类的私有成员；
	类对象的构造顺序显示，进入构造函数体后，进行的是计算，是对成员变量的赋值操作，显然，赋值和初始化是不同的，这样就体现出了效率差异，如果不用成员初始化类表，那么类对自己的类成员分别进行的是一次隐式的默认构造函数的调用，和一次赋值操作符的调用，如果是类对象，这样做效率就得不到保障。
	注意：构造函数需要初始化的数据成员，不论是否显示的出现在构造函数的成员初始化列表中，都会在该处完成初始化，并且初始化的顺序和其在类中声明时的顺序是一致的，与列表的先后顺序无关，所以要特别注意，保证两者顺序一致才能真正保证其效率和准确性。
	
2.数据库范式
	第一范式：确保每列保持原子性, 即不可再分
	第二范式：确保表中的每列都和主键相关
	第三范式：确保每列都和主键直接相关, 而不是间接相关
	
3.数据库的连接
	内连接、左外连接、右外连接、全外连接、交叉连接
	
4.varchar和char
	char的长度是不可变的，而varchar的长度是可变的。
	char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。
	char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
	两者的存储数据都非unicode的字符数据。
	
5.事务
		事务(transaction) 指一组SQL语句;
		回退( rollback )指撤销指定SQL语句的过程;
		提交(commit)指将未存储的SQL语句结果写入数据库表;
		保留点(savepoint)指事务处理中设置的临时占位符(place-holder)，你可以对它发布回退(与回退整个事务处理不同)。
	MySQL中的事务：
		START TRANSACTION	标志事务的开始
		ROLLBACK			回退(撤销)SQL语句,只能在一个事务处理内使用(在执行一条START TRANSACTION命令之后)
		COMMIT				事务提交,在MySQL语句中是隐含提交的,但在事务中不会隐含提交,需使用COMMIT提交
			隐含事务关闭：当ROLLBACK或COMMIT语句执行后,事务会自动关闭
		SAVEPOINT delete1	设置占位符/保留点 ROLLBACK TO delete1——回退到该点
			释放保留点：在事务处理完成之后自动释放。也可以用RELEASE SAVEPOINT明确地释放
		SET autocommit = 0;	设置不自动提交更改
		
	什么是事务, 事务的四大特性
		事务：对数据库中一系列操作进行统一的回滚或提交的操作, 主要用来保证数据的完整性和一致性。
		四大特性：ACID
			原子性Atomicity: 事务包含的所有操作要么全部成功, 要么全部失败回滚
			一致性Consistency: 事务开始前和结束后, 数据库的完整性约束没有被破坏
			隔离性Isolation: 多个用户并发访问数据库时,数据库为每个用户开启的事务, 不能被其他事务的操作干扰, 多个并发事务之间要相互隔离。
			持久性Durability一个事务一旦被提交了, 那么对数据库中数据的改变就是永久性的。
	事务的并发问题：
		脏读： 事务A读取了事务B的数据, 然后B进行回滚操作, 则A读到的数据就是脏数据
		不可重复读：事务A多次读取同一数据, 事务B在事务A多次读取的过程中, 对数据做了更新并提交, 导致事务A多次读取同一数据时, 结果本次事务先后读到的数据不一致。
		幻读：幻读解决了不重复读, 保证了同一事务里, 查询的结果都是事务开始时的状态(一致性)。
	事务的隔离级别：
		读未提交Read uncommitted：另一个事务修改了数据, 但尚未提交, 而本事务中的SELECT会读到这些未提交事务的脏读
		不可重复读Read committed：事务A多次读取同一数据, 事务B在事务A多次读取的过程中, 对数据做了更新并提交, 导致事务A多次读取同一数据时, 结果本次事务先后读到的数据不一致。
		可重复读(MySQL默认)Repeatable read：同一事务里, SELECT的结果是事务开始时时间点的状态, 因此SELECT操作读到的结果会是一致的。但会有幻读。
		串行化Serializable：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样
	
		事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或框架的支持。
		MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行
		事务隔离级别：未提交读时，写数据只会锁住相应的行。
		事务隔离级别为：可重复读时，写数据会锁住整张表。
		事务隔离级别为：串行化时，读写数据都会锁住整张表。

		隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
	嵌套事务：
		概念：子事务在父事务中执行, 子事务是父事务的一部分。

6.存储引擎
	a.MsSQL常见的三种存储引擎InnoDB、MyISAM、MEMORY
		·InnoDB支持事务, MyISAM不支持
		·MyISAM适合查询以及插入为主的应用
		·InnoDB适合频繁修改以及涉及到安全性比较高的应用
		·InnoDB支持外键, MyISAM不支持
		·MySQL5.5.5之后InnoDB是默认引擎(因为事务)
		·InnoDB不支持全文本搜索
		·InnoDB支持行锁
	b.存储引擎的选用
		• 1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。
		• 2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。
		现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。
	c.MyISAM与InnoDB对比
		事务处理方面：
			• MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
			• InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
		锁级别
			• MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
			• InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
		存储结构
			MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。
			InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
		