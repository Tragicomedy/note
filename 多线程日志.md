# 多线程日志

## 日志概述

在服务端编程中，日志是必不可少的。对于关键进程，日志通常要记录：

- 收到的每条内部消息的id（还可以包括关键字段、长度、hash等）
- 收到的每条外部消息的全文
- 发出的每条消息的全文，每条消息都有全局唯一的id
- 关键内部状态的变更

每条日志都有时间戳，这样就能完整追踪分布式系统中一个事件的来龙去脉。

一个日志大体上可以分为前段frontend和后端backend两部分。前端是供应用程序使用的接口(API)，并生成日志消息log message；后端负责把日志消息写到目的地destination。这两部分的接口有可能简单到只有一个回调函数：

```C++
void output(const char* message, int len);
//message字符串是一条完整的日志消息，包含日志级别、时间戳、源文件位置、线程id等基本字段，以及程序输出的具体消息内容
```

![image-20200706202257679](C:\Users\Costco424\AppData\Roaming\Typora\typora-user-images\image-20200706202257679.png)

在多线程程序中，前端和后端都于单线程程序无区别，无非是每个线程有自己的前端，整个程序共用一个后端。但难点在于将日志数据从多个前端高效地传输到后盾，这是一个典型的生产者消费者问题，对生产者（前端）而言，要尽量做到低延迟、低CPU开销、无阻塞；对消费者（后端）而言，要做到足够大的吞吐量。

对C++程序而言，最好整个程序都是用相同的日志库，程序有一个整体的日志输出，而不要各个组件有各自的日志输出。从这个意义上讲，日志库是个singleton。

C++日志库的前端大体上有两种API风格：

- C/Java的printf(fmt, ...)风格：

  ```C++
  log_info("Received %d bytes from %s", len, getClientName().c_str());
  ```

- C++的stream<<风格

  ```C++
  LOG_INFO << “Recevied " << len << " bytes from " << getClientName();
  ```

stream风格的另一个好处是当输出的日志级别高于语句的日志级别时，打印日志是个空操作，运行时开销接近零。比如日志级别为WARNING时，LOG_INFO <<是空操作，不会调用getClientName()函数，减小了开销。

## 多线程异步日志

多线程程序对日志库提出了新的需求：线程安全