1. 回调函数
	什么是回调函数、回调函数的应用
	a.定义
		回调函数简单来说就是一个指向特定函数的指针。
		函数的类型由其参数与返回值共同决定，与函数具体名称无关。
		例：
			//普通函数定义
			int testFun1(int param1,long param2,float param3);
			//函数指针
			int (*pFun)(int, long, float);
	b.意义
		把函数作为参数传递给另一个参数
	c.应用
		对回调函数的使用无非是对函数指针的应用, 回调函数在Linux内核中有大量的应用
		回调函数一般适用于以下几个场合：
			i.事件驱动机制
			ii.通信协议中的“推”模式 ->通信的推/拉模式
			
			
2.概念:  脏页
	在将脏页概念前, 首先要讲一下高速缓存的概念。
	对于系统来说, 硬盘的读写速度远远赶不上内存的读写速度, 故把频繁访问的硬盘数据事\
  先存储到内存当中, 以提高读写速度, 此即高速缓存。Linux是以页作为高速缓存的单位。
	再讲回脏页, 当进程修改了高速缓存中的数据时, 该页内存就被标记为脏页, 内核会在何时\
  的时间里将脏页的数据写到硬盘中去, 以保持高速缓存中数据与硬盘中数据的一致性。

3.Linux进程调度思想
	把进程抽象为进程描述符task_struct: 包含进程必要的数据, 如pid、状态信息、调度信息、优先级、内存页信息
	把调度对象抽象成调度实体sched_entity: 调度实体可以是进程、进程组、用户等。sched_entity包含负载权重值weight、\
  对应的红黑树节点rb_node、虚拟运行时间vruntime等。
	把调度策略/算法抽象为调度类sched_class: 包含一组通用的调度操作接口, 将接口与实现分析。可以根据这组接口实现不同\
  的调度算法, Linux的调度策略包括SCHED_RR、SCHED_FIFO、SCHED_BATCH、SCHED_NORMAL
	把调度的组织抽象为可运行队列rq： 包含自旋锁、经常数量、当前运行的进程描述符、CFS信息结构
	把CFS调度的运行队列信息抽象为cfs_rq: 

4.内核中的资源锁（略）
	内核中的资源锁有自旋锁、信号量、互斥量、读写锁、顺序锁、RCU锁、futex锁
		- 自旋锁：忙等锁
		- 互斥锁/信号线：互斥, 休眠
		- futex锁：互斥不频繁，希望不必每次进入内核（仅在用户空间进程使用的锁, 将内核态的锁变量值映射到用户进程空间中, 这样就避免了查询时陷入内核）
		- 读写锁/顺序锁/RCU锁：读写分开处理

5. 互斥与同步 -->互斥锁与信号量的区别
	互斥：指同一时间只有一个进程可以访问该资源, 没有时序的概念
	同步：包含了多个访问该资源进程的访问的先后顺序
	
6.进程对系统内存的使用
	进程的内存种类有：用来存放数据的堆; 用来执行进程的栈; 与其他进程共用的物理内存(SHR,例如共享库、共享内存); 进程的虚拟地址空间大小(VIRT); \
  应用程序实际正在使用的物理地址大小(RSS); 进程放置执行代码的部分。
	总体来说, 应用程序实际要使用的物理地址由数据、栈、可执行代码三部分。需要最多的是数据内存。
	查看经常资源：/proc/pid/stat*中的statm、status、stat。statm: 关于经常的内存使用信息; stat:全面的信息, 如进程号、缺页次数、启动时间、信号、CPU、进程组等\
  status是用户通常比较关心的内容。
	从操作系统角度来看, 进程分配内存由两种方式, 由两个系统调用完成brk和mmap(不考虑共享内存)
		a.brk: 将数据段.data的最高地址_edata往高地址推
		b.mmap: 在经常的虚拟地址空间中(堆与栈的中间, 文件映射区)找一块空闲的虚拟内存。
		两种方式分配的都是虚内存, 没有分配物理内存。由缺页中断触发物理内存分配, 再建立映射关系。
		标准C库中,提供的malloc、free内存故那里函数, 底层则由brk、mmap、munmap这些系统调用综合实现。
		
7.操作系统实现进程所做的工作：
	i.栈的设计与维护：为每个进程维护一个栈
	ii.进程描述符task_struct
	iii.进程代号/标号：pid ->定位每个task_struct
	iv.进程上下文：保存与恢复进程执行时存储在寄存器上的变量值
	v.进程树：记录进程间的父子关系
	
8. 应用程序(用户进程)之间通信的方法
	i. mmap映射一块共享内存
	ii. System V IPC/POSIX IPC: 信号量、共享内存、消息队列(最常用的选择)
	iii. 匿名的pipe管道
	iv.socket: UNIX Domain socket或普通socket(大量数据通信)
	v.mailbox机制
	vi. 用户端服务的DBUS
	vii. NETLINK_USERSOCK
	
9.内核与用户空间的进程通信(略)
	i.Netlink: 用户程序与内核通信的socket方法
	

10. STL迭代器iterators
	作用、实现的关键点
	
11.TCP粘包现象
	什么是粘包现象、为什么、什么时候需要处理、如何处理
	a.TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包, 从接收缓冲区看, 后一包的数据头紧接着前一包尾。
	b.发送方原因：Nagle算法, 只有上一个分组得到确认, 才会发送下一个分组;
				收集多个小分组, 在一个确认到来时再一起发送.
	  接收方原因：TCP接收到分组时, 不会立即送到英语工程处理, 而是分组保存到接收缓存里, 然后应用程序主动来读缓存。\
				如果TCP接收分组的速度大于应用程序读的速度, 多个包就会被存至缓存, 读取就会有粘包。
	c.当每个数据包毫不相干、甚至是并列关系, 就需要处理粘包。
	d.发送方: 关闭Nagle算法, 使用TCP_NODELAY选项来关闭。
	   接收方: 传输层无法处理, 只能在应用层处理, 1) 格式化数据 2)定长

12.epoll
	epoll是Linux高效网络的基础, 能够高效支持百万级别的句柄监听。
	epoll内部实现为一棵红黑树+一个双向链表。
	当某一进程调用epoll_create方法时, Linux内核会创建一个eventpoll结构体,  两个重要成员:rb_root、list_head.
	
	
Linux系统启动过程(略)
	i.嵌入式Linux
		概括来说嵌入式Linux的启动过程分为：BootROM->BootLoader->kernel->rootfs(->app)
		详细来说, 首先由一段厂家固化在芯片内的启动代码(BootROM)安装一定顺序依次扫描各个启动介质(包括Flash、emmc、uart、网口), 找到有效的引导程序,\
	  从该介质启动引导程序; 这里采用最常用u-boot, u-boot分为两个阶段SPL->u-boot, 第一阶段加载维持启动的必要环境,  
	ii. 普通Linux(电脑)
		BIOS->MBR引导扇区->GRUB->Kernel->init->rc.sysinit->加载内核模块->启动运行级别->读取rc.local