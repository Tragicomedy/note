# 网络

1. 以太网协议头14byte
			协议头						数据		校验
	目的地址	源地址	类型		数据和填充		CRC
		6		  6		  4							 4
		
	
	```c
	#include <stdio.h>
	#include <unistd.h>
	#include <stdlib.h>
	
	#include <sys/poll.h>
	
	#define NETMAP_WITH_LIBS
	
	#include <net/netmap_user.h>
	
	#pragma pack(1)  //1个字节对齐
	
	#define PROTO_IP	0X0800
	#define UDP			17
		
	#define ETH_LENGTH 6
	struct ethhdr{
		unsigned char h_dest[ETH_LENGTH];
		unsigned char h_src[ETH_LENGTH];
		unsigned short h_proto;
	};
	```
	
	
	
2. IP协议头20byte

	```C
	    /********************** 	
	    		0	 4			8		 16	   19	24			   31
         /	————————————————————————————————————————————————————————
	        |	版本  | 首部长度  | 区分服务	|			总长度		
	        |			标识				 | 标志 | 	片偏移
	ip head	|		生存时间	 |   协议	   |		首部校验和
	        |						源	地	址
	        |						目	的	地	址
	         \				可选字段(长度可变)			|	填充	
	            ———————————————————————————————————————————————————————— 
	      ****************************/
	
	struct iphdr {
		unsigned char version:4, //4位版本
					  hdr_len:4; //4位首部长度
		unsigned char tos;	//8位服务类型
		unsigned short tot_len;  //16位总长度(字节数)
		unsigned short id;   //16位标识符
		unsigned short flag:3,	//3位标志
					  offset:13;	//13位片偏移
		unsigned char ttl;	//8位生存周期		TTL默认值64,经过一个网关-1, TTL = 128 回环地址 127.0.0.1——回环
		unsigned char proto; //8位协议
		
	
	unsigned char check; //16位首部校验和
	
	unsigned int sip; //
	unsigned int dip; //
	
	}; //end iphdr
	```
	
	
	
3. UDP协议头8byte
	
	```c
	struct udphdr{
		unsigned short sport;
		unsigned short dport;
		
	
unsigned short length;
	unsigned short check;
	
	};
	```
	
	
	
4. 数据包 (UDP包)
	
	```C
	struct udppkt{
		//协议头
		struct ethhdr eh;
		struct iphdr ip;
		struct udphdr udp;
		//数据包
		unsigned char payload[0]; //柔性数组, 变长
	};
	```
	
	
	
5. main.
	网络分包方法：
		i.  raw socket	原生的socket
		ii. dpdk (网卡里抓取出来的数据)
		iii.netmap	网卡通过mmap映射到内存  -> 操作内存数据与操作网卡数据一样
		iv. pf_ring
		
	netmap:	把网卡的存储空间映射到内存中 ->DMA
			再采用poll监控该块内存里数据是否可读
		

```C
//netmap 
int main(){
	struct nm_desc *nmr = nm_open("netmap:eth0"); //open一块内存
 	if(nmr == NULL) return -1;
 	
 	struct pollid pfd = {0};
 	pfd.fd = nmr->fd;
 	pfd.events = POLLIN;
 	
 	while(1){
 		int ret = poll(&pfd, 1, -1);
 		if(ret < 0) continue;
 		
 		if(pfd.revents & POLLIN){
 			
 			struct nm_pkthdr h;
 			unsigned char *stream = nm_nextpkt(nmr, &h);
 			
 			struct ethhdr *eh = (struct ethhdr*)stream; //强转为以太网的包
 			if(nthos(eh->h_proto) == PORT_IP){ //检测是一个IP包
 				
 				struct udppkt *udp = (struct udppkt*)stream;
 				
 				if(udp->ip.proto == PROTO_UDP){ //判断是UDP包
 					
 					int udp_length = ntohs(udp.length);
 					udp->payload[udp_length-8] = '\0';
 					
 					printf("udp -- >  %s \n")
 					
 				}
 				
 			}
 			
 		}
 	}
}
```

