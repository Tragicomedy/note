1.SSH
	Secure Shell, 一套协议标准, 可以用来实现两台机器之间的安全登陆以及安全的数据传送, 其保证数据安全的原理是非对称加密.
	传统的对称加密使用的是一套秘钥, 数据的加密以及解密都用同一套秘钥, 泄漏风险很高, 存在不安全性。
	非对称加密采用了两套秘钥 - 公钥以及私钥, 其公钥用来加密, 私钥用来解密, 并且通过公钥计算不出私钥，因此私钥谨慎保存在服务端，而公钥可以随便传递，即使泄露也无风险。
	保存SSH安全性的方法, 简单来说就是客户端和服务端各自生成一套私钥和公钥, 并且互相交换公钥, 这样每一条发出的数据都可以用对方的公钥来加密，对方收到后再用自己的私钥来解密。
	两台机器除了各自的一套公、私钥之外，还保存了对方的公钥，因此必然存在一个交换各自公钥的步骤。
	
	具体过程：
		a.首次建立连接的时候的公钥交换 —— 这一步在首次连接时, 数据传送之前
			1.客户端发起链接请求
			2.服务端返回自己的公钥, 以及一个会话ID(即客户端得到服务端公钥)
			3.客户端生成密钥对
			4.客户端用自己的公钥异或会话ID, 计算出一个值, 并用服务端公钥加密
			5.客户端发送加密后的值到服务端, 服务端用私钥解密
			6. 服务端解密后的值异或会话ID, 计算出客户端的公钥(服务端得到客户端公钥)
			7.双方各自持有三个秘钥：自己的公、私钥; 对方的公钥
			注：这个过程中, 可能会受到中间人攻击：首次建立链接时没法确定公钥是否来自服务器, 当客户端的请求被拦截, 返回冒充服务器的秘钥, 则建立链接后所有数据都能被攻击者获取。
		b.登陆
			i.通过SSH来进行密码登录(手动连接)
				1.服务端收到登录请求后, 首先互换公钥
				2.客户端用服务端的公钥加密账号密码并发送
				3.服务端用自己的秘钥解密后得到账号密码,然后进行验证
				4.服务端用客户端的公钥加密验证结果并返回
				5.服务端用自己的秘钥解密后得到验证结果
			ii.利用公钥来登陆(自动连接)
				1.客户端用户必须手动地将自己的公钥添加到服务器一个名叫authorized_keys的文件里，顾名思义，这个文件保存了所有可以远程登录的机器的公钥。
				2.客户端发起登录请求，并且发送一个自己公钥的指纹（具有唯一性，但不是公钥）
				3.服务端根据指纹检测此公钥是否保存在authorized_keys中
				4.若存在，服务端便生成一段随机字符串，然后利用客户端公钥加密并返回
				5.客户端收到后用自己的私钥解密，再利用服务端公钥加密后发回
				6.服务端收到后用自己的私钥解密，如果为同一字符串，则验证通过
				利用公钥登录的关键是必须手动将客户端的公钥添加到服务端，比如GitHub便有这一步骤，添加了之后便可无密码登录。

2.TCP/IP协议中的安全手段
	网络层：IPsec
	传输层：SSL、TLS
	a.安全套接层SSL
		SSL为TCP提供可靠的端到端安全服务。SSL是两个协议层。下层SSL记录协议, 上层SSL握手协议、SSL修改密码规范协议、SSL警报协议、HTTP
		SSL两个重要概念：SSL会话和SSL连接
			连接：提供合适服务类型的一种传输。连接表示的事对等的网络关系, 且连接时短暂的, 每个连接与一个会话相关。
			会话：SSL会话是一个客户端与服务器之间的关联, 会话是通过握手协议创建的, 定义了一组多个连接共享的密码安全参数。
		SSL记录协议过程：消息/应用数据分块(2^14)->压缩->加上MAC->加密->加上SSL头
			SSL头：内容类型(8bit)、主版本号(8bit)、从版本号(8bit)、压缩长度(16位)
		SSL握手协议：建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
	b.传输层安全TLS
		TLS（传输层安全）是更为安全的升级版 SSL。TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善
		在SSL更新到3.0时，IETF对SSL3.0进行了标准化，并添加了少数机制(但是几乎和SSL3.0无差异)，标准化后的IETF更名为TLS1.0(Transport Layer Security 安全传输层协议)，可以说TLS就是SSL的新版本3.1
	c.HTTPS
		结合HTTP(SSL之上的HTTP)和SSL来实现web服务器和web浏览器之间的安全通信
		HTTPS端口443(HTTP 80), 用来唤醒SSL.
		HTTPS加密内容: 请求文档的URL、文档的内容、浏览器格式的内容、cookies、HTTP包头的内容
		
3.mmap
	mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。
	
4.MySQL语法
	  SELECT [ALL｜DISTINCT] <算术表达式列表> [,<算术表达式列表> ]...
	  FROM <表名或视图名列表> [,<算术表达式列表> ]...
	  [ WHERE <条件表达式 1> ]
	  [ GROUP BY <属性列表 1> [ HAVING <条件表达式 2 > ] ]
	  [ ORDER BY <属性列表 2> [ ASC｜DESC ] ] ；
		
	USE         选择一个数据库  USE table
	增删改查 INSERT DELETE UPDATE SELECT
	SELECT   检索			
			检索单个目标 SELECT target FROM table
			检索多个目标 SELECT target1,target2 FROM table
			检索不同的行 SELECT DISTINCT target FROM table  //只显示无重复的值
			检索所有列     SELECT * FROM table
			限制结果	SELECT target FROM table LIMIT num/begin num  //限制num行 or 从begin开始的num行
	ORDER BY 排序
			按指定列对输出排序 SELECT target FROM table ORDER BY column //
			按多列排序 SELECT target FROM table ORDER BY column1, column2 //先按column1排序, 同值则按column2排序
		DESC 降序排序
	WHERE 	过滤数据   //WHERE子句在FROM子句后面
			SELECT target1,target2 FROM table WHERE target2 = num 
			//WHERE子句操作符(注意优先级)  = 等于 / <>不等于 / !=不等于 / <  <=  > >=/ BETWEEN在指定值之间
			BETWEEN ： target1,target2 FROM table WHERE target2 BETWEEN a AND b
		AND	操作符 //多条件过滤
			SELECT target1,target2 FROM table WHERE target2 = num AND target2 < num
		OR 	操作符
		IN	操作符  -->指定范围, 由逗号分隔的清单,全在括号内
		NOT  操作符   -->否定条件
	LIKE	通配符
		% 	百分号通配符 --> %表示任何字符出现任意次数, 比如找包含某字符的单元
			SELECT target FROM table WHERE target LIKE 'abc%'  //找寻target列以abc开头的行
		_	下划线通配符 --> _只匹配单个字符
汇总数据：  聚集函数
	AVG() 	返回某列平均值
	COUNT()	返回某列行数	//COUNT(*)计算行数, 不管是否为NULL  COUNT(column) -> 忽略NULL行
	MAX()	返回某列最大值
	MIN()	返回某列最小值
	SUM()	返回某列值之和
		example：	SELECT AVG(target) AS avg_target FROM table
数据分组:  GROUP BY / HAVING
	GPOUP BY 创建分组, 指MySQL按照target排序并分组数据
		SELECT vend_id,COUNT(*) AS num_prods FROM products GROUP BY vend_id => 输出不同vend_id的数量列表, 会按GROUP BY指定分组数据, 对每个组而不是整个结果进行聚集
		注：使用WITH ROLLUP 关键字可以得到每个分组以及每个分组汇总级别的值
	HAVING	过滤分组  (区别于WHERE的过滤, WHERE过滤的是行, 不能过滤分组)
		SELECT cust_id,COUNT(*) AS orders FROM orders GROUP BY cust_id HAVIND COUNT(*) >= 2 // 过滤分组数量小于2的组

SELECT子句顺序：
	子句		说明					是否必须使用
	SELECT		要返回的列或表达式		是
	FROM		从中检索数据的表		仅在从表中选择数据时使用
	WHERE		行级过滤				否
	GROUP BY 	分组说明				否
	HAVING		组级过滤				否
	OREDER BY	输出顺序排序			否
	LIMIT		要检索的行数			否
	
子查询：MySQL4.1引入
	嵌套在其他查询中的查询, 多表合并查询
	使用子查询进行过滤：
		SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')
	作为计算字段使用子查询:
		SELECT cust_nam,cust_state,(SELECT COUNT(*) FROM orders WHERE orders.id = customers.id) AS orders FROM customers ORDER BY cust_name
			相关子查询：涉及外部查询的子查询WHERE orders.id = customers.id
联结表：JOIN
	作用：数据存储在多个表中, 使用单条SELECT语句检索出数据
	等值联结：
		SELECT vend_name,prod_name,prod_name
		FROM vendors,products
		WHERE vendors.id = products.id  //***按行配对
		ORDER BY vend_name,prod_name
	内部联结：
		SELECT vend_name, prod_name, prod_price
		FROM vendors INNER JOIN products
		  ON Vendors.vend. _id = products.vend _id;
		 以INNER JOIN 联结, 联结条件用ON而不是WHERE, 传递给ON的条件与WHERE相同
	自联结：
	自然联结：LEFT OUTER JOIN / RIGHT OUTER JOIN 同INNER JOIN 使用ON
		LEFT OUTER JOIN从FROM子句的左边表中选择所有行
		RIGHT OUTER JOIN从FROM字句的右边表中选择所有行
	外部联结：
组合查询：
	UNION

全文本搜索：
		并非所有引擎都支持全文本搜索, MyISAM支持, InnoDB不支持。 -->要全文本搜索的话, 建表时要指定使用MyISAM
	启用全文本搜索：
		在创建表时启用, CREAT TABLE语句接收FULLTEXT字句, 它给出被索引列的一个逗号分隔列表
	进行全文搜索： Match() Against()
		Match()用于指定被搜索的列, Against()指定要搜索的表达式
		SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbits')
		传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列, 则必须列出他们(且次序正确
		
更新和删除数据
	UPDATE	UPDATE语句总是以要更新的表的名字开始
		UPDATE customers
		SET cust_email = 'elmer@fudd.com'
		WHERE cust_id = 10005
	SET		用来将新值赋给被更新的列。也可以SET为NULL
	DELETE	删除特定行/删除所有行(省略WHERE)
		DELETE FROM customers
		WHERE cust_id = 10006;
	TRUNCATE TABLE 删除所有行, 比DELETE更快
	
创建和操作表
	CREAT TABLE 		创建表
	PRIMARY KEY(column)	设置column列为主键
	AUTO_INCREMENT 		自动设置为下一个可用值
	DEFAULT				设置默认值
	ENGINE				引擎类型 ENGINE = InnoDB	/ MEMORY / MyISAM
							InnoDB:可靠的事务处理引擎
							MEMORY:功能等同于MyISAM, 但存在内存中, 适用于临时表
							MyISAM:支持全文本搜索, 但不支持事务处理
	ALTER TABLE			更新表
			ALTER TABLE ADD column CHAR(20)   //必须标明数据类型
	DROP TABLE customers 删除整个表
	RENAME TABLE 		重命名表
	
权限管理
	GRANT		赋予权限
	REVOKE		取消赋予权限