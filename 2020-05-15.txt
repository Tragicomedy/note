1. 传参类型声明为常量应用
	为什么？
		a.声明为引用
		如果传入的参数不是引用而是实例, 那么从形参到实参会调用一次复制构造函数. 把参数声明为应用可以避免这样的无谓消耗, 提高代码效率。
		b.声明为const
		在赋值运算符函数内不会改变传入的实例的状态。
	
2.设计赋值运算函数注意点
	设计operator=()函数
	a.把返回值的类型声明为该类型的引用, 并在函数结束返回实例自身的引用(*this)。
		只有返回一个引用, 才允许连续赋值
	b.把传入的参数的类型声明为常量引用。(见1)
	c.释放实例自身已有的内存。否则会导致内存泄漏
	d.判断传入的参数和当前的实例(*this)是否为同一个实例, 若是, 直接返回。否则进行赋值, 释放自身内存,  传入的参数的内存也被释放了。
	
3.内联函数
	定义、优点
		关键字inline, 内联函数是指使用inline关键字定义的函数
		在编译阶段, 就将inline函数的代码嵌入到对应调用了该函数的位置, 仅适用于代码较少的函数。
		优点：减少因为函数调用引起的开销, 包括参数压栈、栈帧的开辟与回收, 寄存器的恢复与保存
				内联后编译器在处理调用内联函数的函数时, 可供分析的代码更多。
	
4.函数调用过程
	i.参数压栈(按逆序, 从又到左), 若参数有对象, 则需要先进行拷贝构造
	ii.保存返回地址：即函数调用结束返回后执行语句的地址
	iii.保存维护原函数栈帧信息的寄存器内容：如SP(堆栈指针)、FP(栈帧指针)等。
	iv.保存一些通用寄存器内容(保护现场)
	v.调用函数
	vi.恢复通用寄存器(还原现场)
	vii.恢复保存原函数栈帧信息的寄存器
	viii.通过移动栈指针, 销毁被调函数栈帧
	xi. 将保存的返回地址出栈, 赋给IP寄存器
	x.通过移动栈指针, 回传给原函数的参数所占用的空间
	
5.函数栈帧
	关键寄存器ebp(函数栈帧栈底)、esp(函数栈帧栈顶)、eip(程序计数器)、eax-edx(通用寄存器)
	与函数调用过程相关

6.C++和JAVA/python的区别
	C++是强类型语言; python是弱类型语言, 动态确定数据类型
	C++是编译型语言, 编译成本地机器码, 可以由操作系统直接运行, 运行效率高; python是一门解释型语言, 先由解释器把源码转换为字节码文件, 再由python虚拟机一条条执行字节码指令
	内存管理：C++堆区内存需要应用程序自行管理; python依靠引用计数机制进行自动内存管理
	多线程：C++; python多线程不能利用多核CPU资源
	类成员变量：C++类外禁止访问私有成员; python只是对私有成员的名称进行了修饰
	
7.C++ 的new关键字、new/deltet与malloc/free区别
	三类：new operator、operator new、 placement new
	
8.C++强制转换类型
	a.const_cast: cons_cast<type_id>(experssion)
		用来修改类型的cv(const、volatile)属性, 不是去除变量的常量性, 而是指向常数对象的指针或引用的常量性
		type_id必须是指针 or 引用 or 指向对象类型的指针
	b.reinterpret_cast: reinterpret_cast<type_id>(experssion)
		改变指针或应用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。
		