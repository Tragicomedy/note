# Makefile

## Makefile简介

`Makefile` 中会定义一系列的规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。
`Makefile` 带来的好处就是“自动化编译”，一旦写好，只需要一个make 命令，整个工程完全自动编译，极大地提高了软件开发的效率。make 命令是一个命令工具，是一个解释makefile 中指令的命令工具，一般来说，大多数的IDE 都有这个命令。

## 结构说明/规则

### 规则

 `Makefile` 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：

```makefile
targets : prerequisites
    command
```

或是

```makefile
targets : prerequisites; command
    command
```

`targets`：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签
`prerequisites`：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有
`command`：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行

### 结构说明

`MakeFile`文件主要包括五个部分：变量定义、显式规则、隐晦规则、文件指示和注释。

**变量定义**

在`MakeFile`中会要定义一系列的变量，变量一般都是字符串，有点像C语言的宏，当`MakeFile`执行时，其中的变量都会被扩展到相应的引用位置上。

**显式规则**

显式规则说明了，如何生成一个或多的的目标文件。这是由 `Makefile`的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。

**隐晦规则**

由于`make`有自动推导功能，所以隐晦的规则可以让我们比较粗糙地书写`MakeFile`，这是由`make`所支持的。

**文件指示**

其包括了三个部分，一个是在一个 `Makefile` 中引用另一个 `Makefile`，就像C语言中的 include 一样；另一个是指根据某些情况指定 `Makefile` 中的有效部分，就像C语言中的预编译 #if 一样；还有就是定义一个多行的命令。

**注释**

`MakeFile`中只有行注释，和UNIX的Shell脚本一样，其注释使用"#"字符。如果需要在你的`MakeFile`中使用"#"字符，可以用反斜进行转义，如"\\#"。

## 工作流程

### 工作流程

例：

```makefile
main:main.o test1.o test2.o
	gcc main.o test1.o test2.o -o main
main.o:main.c test.h
	gcc -c main.c -o main.o
test1.o:test1.c test.h
	gcc -c test1.c -o test1.o
test2.o:test2.c test.h
	gcc -c test2.c -o test2.o
```

​		当在 shell 提示符下输入 `make` 命令以后。 `make` 读取当前目录下的 `Makefile` 文件，并将 `Makefile`文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在例子中，第一个规则就是目标 "main" 所在的规则。规则描述了 "main" 的依赖关系，并定义了链接 ".o" 文件生成目标 "main" 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 "main" 的所有的依赖文件（例子中的那些 ".o" 文件）的更新规则（以这些 ".o" 文件为目标的规则）。

​		对这些 ".o" 文件为目标的规则处理有下列三种情况：

- 目标 ".o" 文件不存在，使用其描述规则创建它；
- 目标 ".o" 文件存在，目标 ".o" 文件所依赖的 ".c" 源文件 ".h" 文件中的任何一个比目标 ".o" 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；
- 目标 ".o" 文件存在，目标 ".o" 文件比它的任何一个依赖文件（".c" 源文件、".h" 文件）“更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做。

### 清除工作目录中的过程文件

​		因为使用的时候会产生许多中间文件使得文件很混乱，在编写 `Makefile` 文件的时候会在末尾加上这样的规则语句：

```makefile
.PHONY:clean
clean:
    rm -rf *.o test
```

​		其中 `"*.o`" 是执行过程中产生的中间文件，`"test"` 是最终生成的执行文件。我们可以看到 `clean` 是独立的，它只是一个伪目标，不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 `make` 的时候也不会执行下面的命令。在shell 中执行` "make clean"` 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。

## Makefile通配符

Makefile 是可以使用 shell 命令的，所以 shell 支持的通配符在 Makefile 中也是同样适用的。 shell 中使用的通配符有："*"，"?"，"[...]"。具体看一下这些通配符的表示含义和具体的使用方法。

| 通配符 | 使用说明                     |
| ------ | ---------------------------- |
| *      | 匹配0个或是任意个字符        |
| ?      | 匹配任意一个字符             |
| []     | 可以指定匹配的字符放在"[]"中 |

通配符可以出现在模式的规则中，也可以出现在命令中，详细的使用情况如下。

### 匹配符号%

Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。

## 变量的定义与使用

### 变量的定义

`Makefile`文件中定义变量的基本语法为

```makefile
变量名称 = 值列表
```

变量的名称可以由大小写字母、阿拉伯数字和下划线构成。等号左右的空白符没有明确的要求，因为在执行 make 的时候多余的空白符会被自动的删除。至于值列表，既可以是零项，又可以是一项或者是多项。

调用变量的时候可以用 "$(VALUE_LIST)" 或者是 "${VALUE_LIST}" 来替换，这就是变量的引用。

```makefile
OBJ=main.o test.o test1.o test2.o
test:$(OBJ)
      gcc -o test $(OBJ)
```

当要添加或者是删除某个依赖文件的时候，我们只需要改变变量 "OBJ" 的值就可以了。

### 变量的基本赋值

`Makefile` 的变量的四种基本赋值方式：

-  简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
-  递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
-  条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
-  追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

### 变量的引用

要引用某个变量， 只写一个“ $”符号，后面是在括号里的变量名即可。

## 自动化变量

​		自动化变量可以理解为由 `Makefile` 自动产生的变量。在模式规则中，规则的目标和依赖的文件名代表了一类的文件。规则的命令是对所有这一类文件的描述。

​		那么模式规则命令中该如何表示文件呢？就需要使用“自动化变量”，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行的说明：

| 变量 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| $@   | 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 |
| $%   | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |
| $<   | 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |
| $?   | 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。 |
| $^   | 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 |
| $+   | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 |
| $*   | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 |

## 实例

### 在`Makefile`中使用变量

```makefile
OBJS = filel.o file2.o
xx = g++
CFLAGS = -Wall -O -g

helloworld : $(0BJS)
	$(XX) $(0BJS) -o helloworld
	
file2.o : file2.cpp file1.h
	$(XX) $(CFLAGS) -c file2 . cpp -o file2.o
	
file1.o : file1.cpp file1. h
	$(XX) $(CFLAGS) -c file1.cpp -o file1.o
	
clean:
	rm -rf *.o helloworld
```

执行make 命令后提示：

```shell
g++ -Wall -o -g -c file1.cpp -o file1.o
g++ -Wall -o -g -c file2. cpp -o file2.o
g++ file1.o file2.o -o helloworld
```

​		`CFLAGS = -Wall -O -g` ：配置编译器设置，并把它赋值给CFLAGS 变茧， 其中每个部分
含义为： ① `-Wall` ：输出所有的警告信息；②`-O` ：编译时进行优化； ③ `-g` ： 表示编译debug 版本。

### 在`Makefile`中使用函数

```makefile
CC = gcc
XX = g++
CFLAGS = -Wall -O -g
TARGET = helloworld

%.o ： %.c
	$(CC) $(CFLAGS) -c $< -o $@
	
%.o ： %.cpp
	$(XX) $(CFLAGS) -c $< -o $@
	
SOURCES = $(wildeard *.c *.cpp)
OBJS = $(patsubst %.c, %.o , $(patsubst %.cpp, .o, $(SOURCES)))

$(TARGET) : $(0BJS)
	$(XX) $(0BJS) -o $(TARGET)
clean :
rm -rf * . o helloworld
```

 执行make 命令输出：

```shell
g++ -Wall -o -g -c file1.cpp -o file1.o
g++ -Wall -o -g -c file2. cpp -o file2.o
g++ file1.o file2.o -o helloworld
```

​		在`Makefile`规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失配。在这种情况下如果需要通配符有效，需要使用函数wildcard。

​		`patsubst`函数，用于匹配替换，有3个参数。第一个是一个需要匹配的式样，第二个表示用什么来替换它，第三个是一个需要被处理的由空格分隔的列表，比如：

```makefile
$(patsubst %.c, %.o, $(dir) )
```

是指用`patsubst`把`$(dir)`中的变量符合后缀是`.c`的全部替换成`.o`。

```Makefile
OBJS = $(patsubst %.c, %.o , $(patsubst %.cpp, .o, $(SOURCES)))
```

上一行则表示把文件列表中所有的`.c`、`.cpp`字符变成`.o`，形成一个新的文件列表，然后存入`OBJS`变量中。

```makefile
%.o ： %.c
	$(CC) $(CFLAGS) -c $< -o $@
	
%.o ： %.cpp
	$(XX) $(CFLAGS) -c $< -o $@
```

这几句表示把所有的`.c`、`.cpp`文件编译成`.o`文件。

​		这里有3个比较有用的内部变量:①$@扩展成当前规则的目的文件名;②$<扩展成依赖列表中的第一个依靠文件;③而$^扩展成整个依赖的列表(除掉了里面所有重复的文件名)。

​		到这里就已经能够编写一个比较简单、通用的`makefile`文件了，需要注意的是上面所有的例子都假定所有的文件都在同一个目录下，不包含子目录。